{"version":3,"sources":["../src/index.ts","../src/components/FormatMessage.tsx","../src/utils/parser.tsx"],"sourcesContent":["export * from \"./components/FormatMessage\"\n","import type { ReactNode } from \"react\";\n\nimport { MessageFormat } from \"messageformat\";\nimport { parser } from \"../utils/parser\";\n\ntype FormatMessageProps = {\n  msg: string;\n  input: Record<string, string>; // Key value store for kv inserted to mf\n};\n\n/**\n * Render a localized, markup-aware message as a React node.\n *\n * This component compiles the provided `msg` with `messageformat`,\n * converts it to an array of `MessagePart`s via `formatToParts(input)`, and\n * then turns those parts into React elements using the internal `parser`.\n *\n * Variables and ICU formats (e.g., plural/select) are handled by\n * `messageformat`. Bidi isolation markers are preserved.\n *\n * @example\n * // msg as a literal string:\n * <FormatMessage\n *   msg=\"Welcome, <bold>{name}</bold>!\"\n *   input={{ name: \"Name\" }}\n * />\n */\nexport function FormatMessage({ msg, input }: FormatMessageProps): ReactNode {\n  // NOTE: msg should be one of the message keys from a json file. msg arg should also be rename\n  // then, read the actual message from the json file.\n  const mf = new MessageFormat([\"no\"], msg);\n  const parts = mf.formatToParts(input);\n\n  return parser({ parts });\n}\n","import type { MessagePart } from \"messageformat\";\nimport type { ReactNode } from \"react\";\n\ntype SlotMap = Record<string, (children: React.ReactNode) => React.ReactNode>;\n\nconst defaultSlots: SlotMap = {\n  bold: (children) => <strong>{children}</strong>,\n  italic: (children) => <em>{children}</em>,\n  underline: (children) => <u>{children}</u>,\n};\n\ntype ParserProps = {\n  parts: MessagePart<never>[];\n};\n\n/**\n * Parses MessagePart[] array defined my messageformat.\n * Returns a ReactNode. The returned ReactNode is a built of each part provided in the parts parameter.\n * @param parts array of `MessagePart`s\n */\nexport function parser({ parts }: ParserProps): ReactNode {\n  type Frame = { name: string; children: React.ReactNode[] };\n  console.log(parts);\n\n  const root: Frame = { name: \"__root__\", children: [] };\n  const stack: Frame[] = [root];\n\n  const push = (node: React.ReactNode) =>\n    stack[stack.length - 1]?.children.push(node);\n\n  for (const part of parts) {\n    if (part.type === \"text\") {\n      push(part.value);\n    } else if (part.type === \"string\") {\n      push(part.value ?? \"\");\n    } else if (part.type === \"bidiIsolation\") {\n      push(part.value === \"⁨\" ? \"\\u2068\" : \"\\u2069\");\n    } else if (part.type === \"markup\" && part.kind === \"open\") {\n      stack.push({ name: part.name, children: [] });\n    } else if (part.type === \"markup\" && part.kind === \"close\") {\n      const frame = stack.pop();\n\n      if (!frame || frame.name !== part.name) {\n        push(frame ? frame.children : null);\n        continue;\n      }\n\n      const render = defaultSlots[frame.name];\n      push(\n        render\n          ? render(wrapChildren(frame.children))\n          : wrapChildren(frame.children)\n      );\n    }\n  }\n\n  while (stack.length > 1) {\n    const frame = stack.pop()!;\n    stack[stack.length - 1]?.children.push(...frame.children);\n  }\n\n  return wrapChildren(root.children);\n}\n\nfunction wrapChildren(children: ReactNode[]) {\n  return children.length === 1 ? children[0] : children;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACEA,2BAA8B;;;ACIR;AADtB,IAAM,eAAwB;AAAA,EAC5B,MAAM,CAAC,aAAa,4CAAC,YAAQ,UAAS;AAAA,EACtC,QAAQ,CAAC,aAAa,4CAAC,QAAI,UAAS;AAAA,EACpC,WAAW,CAAC,aAAa,4CAAC,OAAG,UAAS;AACxC;AAWO,SAAS,OAAO,EAAE,MAAM,GAA2B;AAExD,UAAQ,IAAI,KAAK;AAEjB,QAAM,OAAc,EAAE,MAAM,YAAY,UAAU,CAAC,EAAE;AACrD,QAAM,QAAiB,CAAC,IAAI;AAE5B,QAAM,OAAO,CAAC,SACZ,MAAM,MAAM,SAAS,CAAC,GAAG,SAAS,KAAK,IAAI;AAE7C,aAAW,QAAQ,OAAO;AACxB,QAAI,KAAK,SAAS,QAAQ;AACxB,WAAK,KAAK,KAAK;AAAA,IACjB,WAAW,KAAK,SAAS,UAAU;AACjC,WAAK,KAAK,SAAS,EAAE;AAAA,IACvB,WAAW,KAAK,SAAS,iBAAiB;AACxC,WAAK,KAAK,UAAU,WAAM,WAAW,QAAQ;AAAA,IAC/C,WAAW,KAAK,SAAS,YAAY,KAAK,SAAS,QAAQ;AACzD,YAAM,KAAK,EAAE,MAAM,KAAK,MAAM,UAAU,CAAC,EAAE,CAAC;AAAA,IAC9C,WAAW,KAAK,SAAS,YAAY,KAAK,SAAS,SAAS;AAC1D,YAAM,QAAQ,MAAM,IAAI;AAExB,UAAI,CAAC,SAAS,MAAM,SAAS,KAAK,MAAM;AACtC,aAAK,QAAQ,MAAM,WAAW,IAAI;AAClC;AAAA,MACF;AAEA,YAAM,SAAS,aAAa,MAAM,IAAI;AACtC;AAAA,QACE,SACI,OAAO,aAAa,MAAM,QAAQ,CAAC,IACnC,aAAa,MAAM,QAAQ;AAAA,MACjC;AAAA,IACF;AAAA,EACF;AAEA,SAAO,MAAM,SAAS,GAAG;AACvB,UAAM,QAAQ,MAAM,IAAI;AACxB,UAAM,MAAM,SAAS,CAAC,GAAG,SAAS,KAAK,GAAG,MAAM,QAAQ;AAAA,EAC1D;AAEA,SAAO,aAAa,KAAK,QAAQ;AACnC;AAEA,SAAS,aAAa,UAAuB;AAC3C,SAAO,SAAS,WAAW,IAAI,SAAS,CAAC,IAAI;AAC/C;;;ADvCO,SAAS,cAAc,EAAE,KAAK,MAAM,GAAkC;AAG3E,QAAM,KAAK,IAAI,mCAAc,CAAC,IAAI,GAAG,GAAG;AACxC,QAAM,QAAQ,GAAG,cAAc,KAAK;AAEpC,SAAO,OAAO,EAAE,MAAM,CAAC;AACzB;","names":[]}